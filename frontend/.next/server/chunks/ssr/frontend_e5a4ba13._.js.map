{"version":3,"sources":["../../../../../frontend/node_modules/next/src/client/components/readonly-url-search-params.ts","../../../../../frontend/node_modules/next/src/client/components/unrecognized-action-error.ts","../../../../../frontend/node_modules/next/src/client/components/redirect-status-code.ts","../../../../../frontend/node_modules/next/src/client/components/redirect-error.ts","../../../../../frontend/node_modules/next/src/client/components/redirect.ts","../../../../../frontend/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts","../../../../../frontend/node_modules/next/src/client/components/not-found.ts","../../../../../frontend/node_modules/next/src/client/components/forbidden.ts","../../../../../frontend/node_modules/next/src/client/components/unauthorized.ts","../../../../../frontend/node_modules/next/src/server/dynamic-rendering-utils.ts","../../../../../frontend/node_modules/next/src/server/lib/router-utils/is-postpone.ts","../../../../../frontend/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","../../../../../frontend/node_modules/next/src/client/components/is-next-router-error.ts","../../../../../frontend/node_modules/next/src/client/components/hooks-server-context.ts","../../../../../frontend/node_modules/next/src/client/components/static-generation-bailout.ts","../../../../../frontend/node_modules/next/src/lib/framework/boundary-constants.tsx","../../../../../frontend/node_modules/next/src/lib/scheduler.ts","../../../../../frontend/node_modules/next/src/shared/lib/invariant-error.ts","../../../../../frontend/node_modules/next/src/server/app-render/staged-rendering.ts","../../../../../frontend/node_modules/next/src/server/app-render/dynamic-rendering.ts","../../../../../frontend/node_modules/next/src/client/components/unstable-rethrow.server.ts","../../../../../frontend/node_modules/next/src/client/components/unstable-rethrow.ts","../../../../../frontend/node_modules/next/src/client/components/navigation.react-server.ts","../../../../../frontend/node_modules/next/src/client/components/navigation.ts","../../../../../frontend/node_modules/next/navigation.js","../../../../../frontend/node_modules/%40vercel/analytics/src/nextjs/index.tsx","../../../../../frontend/node_modules/%40vercel/analytics/src/react.tsx","../../../../../frontend/node_modules/%40vercel/analytics/package.json","../../../../../frontend/node_modules/%40vercel/analytics/src/queue.ts","../../../../../frontend/node_modules/%40vercel/analytics/src/utils.ts","../../../../../frontend/node_modules/%40vercel/analytics/src/generic.ts","../../../../../frontend/node_modules/%40vercel/analytics/src/nextjs/utils.ts","../../../../../frontend/node_modules/eventemitter3/index.js","../../../../../frontend/node_modules/%40tanstack/query-core/build/modern/queryClient.js","../../../../../frontend/node_modules/zustand/esm/middleware.mjs","../../../../../frontend/node_modules/zustand/esm/vanilla.mjs","../../../../../frontend/providers/web3-provider.tsx","../../../../../frontend/node_modules/eventemitter3/index.mjs","../../../../../frontend/lib/wagmi-config.ts","../../../../../frontend/node_modules/%40wagmi/core/src/utils/uid.ts","../../../../../frontend/node_modules/viem/utils/promise/withTimeout.ts","../../../../../frontend/node_modules/%40wagmi/core/src/connectors/createConnector.ts","../../../../../frontend/node_modules/%40wagmi/core/src/utils/deserialize.ts","../../../../../frontend/node_modules/%40wagmi/core/src/createStorage.ts","../../../../../frontend/node_modules/viem/errors/transport.ts","../../../../../frontend/node_modules/%40wagmi/core/src/createConfig.ts","../../../../../frontend/node_modules/viem/utils/rpc/http.ts","../../../../../frontend/node_modules/viem/clients/transports/http.ts","../../../../../frontend/node_modules/%40wagmi/core/src/connectors/injected.ts","../../../../../frontend/node_modules/%40tanstack/query-core/src/queryCache.ts","../../../../../frontend/node_modules/%40tanstack/query-core/build/modern/queryCache.js","../../../../../frontend/node_modules/%40tanstack/query-core/build/modern/mutationCache.js","../../../../../frontend/node_modules/viem/utils/rpc/id.ts","../../../../../frontend/node_modules/%40wagmi/core/src/createEmitter.ts","../../../../../frontend/node_modules/%40wagmi/core/src/utils/serialize.ts","../../../../../frontend/node_modules/%40tanstack/query-core/src/mutationCache.ts","../../../../../frontend/node_modules/%40tanstack/query-core/src/queryClient.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n","export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n","const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Static = 1,\n  Runtime = 2,\n  Dynamic = 3,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Static\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  constructor(private abortSignal: AbortSignal | null = null) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (this.currentStage < RenderStage.Dynamic) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n    }\n  }\n\n  advanceStage(stage: NonStaticRenderStage) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (this.currentStage >= stage) {\n      return\n    }\n    this.currentStage = stage\n    // Note that we might be going directly from Static to Dynamic,\n    // so we need to resolve the runtime stage as well.\n    if (stage >= RenderStage.Runtime) {\n      this.runtimeStagePromise.resolve()\n    }\n    if (stage >= RenderStage.Dynamic) {\n      this.dynamicStagePromise.resolve()\n    }\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from './staged-rendering'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of the prerender stage\n  if (requestStore.stagedRendering) {\n    // TODO: error for sync IO in the runtime stage\n    // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n    requestStore.stagedRendering.advanceStage(RenderStage.Dynamic)\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n","import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n","module.exports = require('./dist/client/components/navigation')\n","import React, { Suspense } from 'react';\nimport { Analytics as AnalyticsScript } from '../react';\nimport type { AnalyticsProps } from '../types';\nimport { useRoute } from './utils';\n\ntype Props = Omit<AnalyticsProps, 'route'>;\n\nfunction AnalyticsComponent(props: Props): React.ReactElement {\n  const { route, path } = useRoute();\n\n  return (\n    <AnalyticsScript path={path} route={route} {...props} framework=\"next\" />\n  );\n}\n\nexport function Analytics(props: Props): React.ReactElement {\n  return (\n    <Suspense fallback={null}>\n      <AnalyticsComponent {...props} />\n    </Suspense>\n  );\n}\n\nexport type { AnalyticsProps };\n","import { useEffect } from 'react';\nimport { inject, track, pageview } from './generic';\nimport type { AnalyticsProps } from './types';\n\n/**\n * Injects the Vercel Web Analytics script into the page head and starts tracking page views. Read more in our [documentation](https://vercel.com/docs/concepts/analytics/package).\n * @param [props] - Analytics options.\n * @param [props.mode] - The mode to use for the analytics script. Defaults to `auto`.\n *  - `auto` - Automatically detect the environment.  Uses `production` if the environment cannot be determined.\n *  - `production` - Always use the production script. (Sends events to the server)\n *  - `development` - Always use the development script. (Logs events to the console)\n * @param [props.debug] - Whether to enable debug logging in development. Defaults to `true`.\n * @param [props.beforeSend] - A middleware function to modify events before they are sent. Should return the event object or `null` to cancel the event.\n * @example\n * ```js\n * import { Analytics } from '@vercel/analytics/react';\n *\n * export default function App() {\n *  return (\n *   <div>\n *    <Analytics />\n *    <h1>My App</h1>\n *  </div>\n * );\n * }\n * ```\n */\nfunction Analytics(\n  props: AnalyticsProps & {\n    framework?: string;\n    path?: string | null;\n  }\n): null {\n  useEffect(() => {\n    inject({\n      framework: props.framework || 'react',\n      ...(props.route !== undefined && { disableAutoTrack: true }),\n      ...props,\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- only run once\n  }, []);\n\n  useEffect(() => {\n    if (props.route && props.path) {\n      pageview({\n        route: props.route,\n        path: props.path,\n      });\n    }\n  }, [props.route, props.path]);\n\n  return null;\n}\n\nexport { track, Analytics };\nexport type { AnalyticsProps };\n","{\n  \"name\": \"@vercel/analytics\",\n  \"version\": \"1.3.1\",\n  \"description\": \"Gain real-time traffic insights with Vercel Web Analytics\",\n  \"keywords\": [\n    \"analytics\",\n    \"vercel\"\n  ],\n  \"repository\": {\n    \"url\": \"github:vercel/analytics\",\n    \"directory\": \"packages/web\"\n  },\n  \"license\": \"MPL-2.0\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": {\n      \"browser\": \"./dist/index.mjs\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./react\": {\n      \"browser\": \"./dist/react/index.mjs\",\n      \"import\": \"./dist/react/index.mjs\",\n      \"require\": \"./dist/react/index.js\"\n    },\n    \"./next\": {\n      \"browser\": \"./dist/next/index.mjs\",\n      \"import\": \"./dist/next/index.mjs\",\n      \"require\": \"./dist/next/index.js\"\n    },\n    \"./server\": {\n      \"node\": \"./dist/server/index.js\",\n      \"edge-light\": \"./dist/server/index.mjs\",\n      \"import\": \"./dist/server/index.mjs\",\n      \"require\": \"./dist/server/index.js\",\n      \"default\": \"./dist/server/index.js\"\n    }\n  },\n  \"main\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"dist/index.d.ts\"\n      ],\n      \"react\": [\n        \"dist/react/index.d.ts\"\n      ],\n      \"server\": [\n        \"dist/server/index.d.ts\"\n      ],\n      \"next\": [\n        \"dist/next/index.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"lint\": \"eslint .\",\n    \"lint-fix\": \"eslint . --fix\",\n    \"test\": \"jest\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\n      \"@vercel/eslint-config\"\n    ],\n    \"rules\": {\n      \"tsdoc/syntax\": \"off\"\n    },\n    \"ignorePatterns\": [\n      \"jest.setup.ts\"\n    ]\n  },\n  \"dependencies\": {\n    \"server-only\": \"^0.0.1\"\n  },\n  \"devDependencies\": {\n    \"@swc/core\": \"^1.3.66\",\n    \"@swc/jest\": \"^0.2.26\",\n    \"@testing-library/jest-dom\": \"^5.16.5\",\n    \"@testing-library/react\": \"^14.0.0\",\n    \"@types/jest\": \"^29.5.2\",\n    \"@types/node\": \"^20.3.1\",\n    \"@types/react\": \"^18.2.14\",\n    \"@types/testing-library__jest-dom\": \"^5.14.6\",\n    \"@vercel/eslint-config\": \"workspace:0.0.0\",\n    \"jest\": \"^29.5.0\",\n    \"jest-environment-jsdom\": \"^29.5.0\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"tsup\": \"7.1.0\"\n  },\n  \"peerDependencies\": {\n    \"next\": \">= 13\",\n    \"react\": \"^18 || ^19\"\n  },\n  \"peerDependenciesMeta\": {\n    \"next\": {\n      \"optional\": true\n    },\n    \"react\": {\n      \"optional\": true\n    }\n  }\n}\n","export const initQueue = (): void => {\n  // initialize va until script is loaded\n  if (window.va) return;\n\n  window.va = function a(...params): void {\n    (window.vaq = window.vaq || []).push(params);\n  };\n};\n","import type { AllowedPropertyValues, Mode } from './types';\n\nexport function isBrowser(): boolean {\n  return typeof window !== 'undefined';\n}\n\nfunction detectEnvironment(): 'development' | 'production' {\n  try {\n    const env = process.env.NODE_ENV;\n    if (env === 'development' || env === 'test') {\n      return 'development';\n    }\n  } catch (e) {\n    // do nothing, this is okay\n  }\n  return 'production';\n}\n\nexport function setMode(mode: Mode = 'auto'): void {\n  if (mode === 'auto') {\n    window.vam = detectEnvironment();\n    return;\n  }\n\n  window.vam = mode;\n}\n\nexport function getMode(): Mode {\n  const mode = isBrowser() ? window.vam : detectEnvironment();\n  return mode || 'production';\n}\n\nexport function isProduction(): boolean {\n  return getMode() === 'production';\n}\n\nexport function isDevelopment(): boolean {\n  return getMode() === 'development';\n}\n\nfunction removeKey(\n  key: string,\n  { [key]: _, ...rest }\n): Record<string, unknown> {\n  return rest;\n}\n\nexport function parseProperties(\n  properties: Record<string, unknown> | undefined,\n  options: {\n    strip?: boolean;\n  }\n): Error | Record<string, AllowedPropertyValues> | undefined {\n  if (!properties) return undefined;\n  let props = properties;\n  const errorProperties: string[] = [];\n  for (const [key, value] of Object.entries(properties)) {\n    if (typeof value === 'object' && value !== null) {\n      if (options.strip) {\n        props = removeKey(key, props);\n      } else {\n        errorProperties.push(key);\n      }\n    }\n  }\n\n  if (errorProperties.length > 0 && !options.strip) {\n    throw Error(\n      `The following properties are not valid: ${errorProperties.join(\n        ', '\n      )}. Only strings, numbers, booleans, and null are allowed.`\n    );\n  }\n  return props as Record<string, AllowedPropertyValues>;\n}\n\nexport function computeRoute(\n  pathname: string | null,\n  pathParams: Record<string, string | string[]> | null\n): string | null {\n  if (!pathname || !pathParams) {\n    return pathname;\n  }\n\n  let result = pathname;\n  try {\n    const entries = Object.entries(pathParams);\n    // simple keys must be handled first\n    for (const [key, value] of entries) {\n      if (!Array.isArray(value)) {\n        const matcher = turnValueToRegExp(value);\n        if (matcher.test(result)) {\n          result = result.replace(matcher, `/[${key}]`);\n        }\n      }\n    }\n    // array values next\n    for (const [key, value] of entries) {\n      if (Array.isArray(value)) {\n        const matcher = turnValueToRegExp(value.join('/'));\n        if (matcher.test(result)) {\n          result = result.replace(matcher, `/[...${key}]`);\n        }\n      }\n    }\n    return result;\n  } catch (e) {\n    return pathname;\n  }\n}\n\nfunction turnValueToRegExp(value: string): RegExp {\n  return new RegExp(`/${escapeRegExp(value)}(?=[/?#]|$)`);\n}\n\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import { name as packageName, version } from '../package.json';\nimport { initQueue } from './queue';\nimport type {\n  AllowedPropertyValues,\n  AnalyticsProps,\n  FlagsDataInput,\n} from './types';\nimport {\n  isBrowser,\n  parseProperties,\n  setMode,\n  isDevelopment,\n  isProduction,\n} from './utils';\n\nexport const DEV_SCRIPT_URL =\n  'https://va.vercel-scripts.com/v1/script.debug.js';\nexport const PROD_SCRIPT_URL = '/_vercel/insights/script.js';\n\n/**\n * Injects the Vercel Web Analytics script into the page head and starts tracking page views. Read more in our [documentation](https://vercel.com/docs/concepts/analytics/package).\n * @param [props] - Analytics options.\n * @param [props.mode] - The mode to use for the analytics script. Defaults to `auto`.\n *  - `auto` - Automatically detect the environment.  Uses `production` if the environment cannot be determined.\n *  - `production` - Always use the production script. (Sends events to the server)\n *  - `development` - Always use the development script. (Logs events to the console)\n * @param [props.debug] - Whether to enable debug logging in development. Defaults to `true`.\n * @param [props.beforeSend] - A middleware function to modify events before they are sent. Should return the event object or `null` to cancel the event.\n * @param [props.dsn] - The DSN of the project to send events to. Only required when self-hosting.\n */\nfunction inject(\n  props: AnalyticsProps & {\n    framework?: string;\n  } = {\n    debug: true,\n  }\n): void {\n  if (!isBrowser()) return;\n\n  setMode(props.mode);\n\n  initQueue();\n\n  if (props.beforeSend) {\n    window.va?.('beforeSend', props.beforeSend);\n  }\n\n  const src =\n    props.scriptSrc || (isDevelopment() ? DEV_SCRIPT_URL : PROD_SCRIPT_URL);\n\n  if (document.head.querySelector(`script[src*=\"${src}\"]`)) return;\n\n  const script = document.createElement('script');\n  script.src = src;\n  script.defer = true;\n  script.dataset.sdkn =\n    packageName + (props.framework ? `/${props.framework}` : '');\n  script.dataset.sdkv = version;\n\n  if (props.disableAutoTrack) {\n    script.dataset.disableAutoTrack = '1';\n  }\n  if (props.endpoint) {\n    script.dataset.endpoint = props.endpoint;\n  }\n  if (props.dsn) {\n    script.dataset.dsn = props.dsn;\n  }\n\n  script.onerror = (): void => {\n    const errorMessage = isDevelopment()\n      ? 'Please check if any ad blockers are enabled and try again.'\n      : 'Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information.';\n\n    // eslint-disable-next-line no-console -- Logging to console is intentional\n    console.log(\n      `[Vercel Web Analytics] Failed to load script from ${src}. ${errorMessage}`\n    );\n  };\n\n  if (isDevelopment() && props.debug === false) {\n    script.dataset.debug = 'false';\n  }\n\n  document.head.appendChild(script);\n}\n\n/**\n * Tracks a custom event. Please refer to the [documentation](https://vercel.com/docs/concepts/analytics/custom-events) for more information on custom events.\n * @param name - The name of the event.\n * * Examples: `Purchase`, `Click Button`, or `Play Video`.\n * @param [properties] - Additional properties of the event. Nested objects are not supported. Allowed values are `string`, `number`, `boolean`, and `null`.\n */\nfunction track(\n  name: string,\n  properties?: Record<string, AllowedPropertyValues>,\n  options?: {\n    flags?: FlagsDataInput;\n  }\n): void {\n  if (!isBrowser()) {\n    const msg =\n      '[Vercel Web Analytics] Please import `track` from `@vercel/analytics/server` when using this function in a server environment';\n\n    if (isProduction()) {\n      // eslint-disable-next-line no-console -- Show warning in production\n      console.warn(msg);\n    } else {\n      throw new Error(msg);\n    }\n\n    return;\n  }\n\n  if (!properties) {\n    window.va?.('event', { name, options });\n    return;\n  }\n\n  try {\n    const props = parseProperties(properties, {\n      strip: isProduction(),\n    });\n\n    window.va?.('event', {\n      name,\n      data: props,\n      options,\n    });\n  } catch (err) {\n    if (err instanceof Error && isDevelopment()) {\n      // eslint-disable-next-line no-console -- Logging to console is intentional\n      console.error(err);\n    }\n  }\n}\n\nfunction pageview({ route, path }: { route?: string; path?: string }): void {\n  window.va?.('pageview', {\n    route,\n    path,\n  });\n}\n\nexport { inject, track, pageview };\nexport type { AnalyticsProps };\n\n// eslint-disable-next-line import/no-default-export -- Default export is intentional\nexport default {\n  inject,\n  track,\n};\n","'use client';\nimport { useParams, usePathname, useSearchParams } from 'next/navigation.js';\nimport { computeRoute } from '../utils';\n\nexport const useRoute = (): {\n  route: string | null;\n  path: string;\n} => {\n  const params = useParams();\n  const searchParams = useSearchParams();\n  const path = usePathname();\n\n  const finalParams = {\n    ...Object.fromEntries(searchParams.entries()),\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- can be empty in pages router\n    ...(params || {}),\n  };\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- can be empty in pages router\n    route: params ? computeRoute(path, finalParams) : null,\n    path,\n  };\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n","'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WagmiProvider } from 'wagmi';\nimport { config } from '@/lib/wagmi-config';\nimport { useState, type ReactNode } from 'react';\n\nexport function Web3Provider({ children }: { children: ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n\n  return (\n    <WagmiProvider config={config}>\n      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n    </WagmiProvider>\n  );\n}\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","'use client';\n\nimport { http, createConfig } from 'wagmi';\nimport { mantle, mantleSepoliaTestnet } from 'wagmi/chains';\nimport { injected } from 'wagmi/connectors';\n\n// Simplified config without WalletConnect to avoid build issues\n// WalletConnect can be added later after fixing Turbopack issues\nexport const config = createConfig({\n  chains: [mantleSepoliaTestnet, mantle],\n  connectors: [\n    injected(),\n  ],\n  transports: {\n    [mantleSepoliaTestnet.id]: http('https://mantle-sepolia.drpc.org'),\n    [mantle.id]: http('https://rpc.mantle.xyz'),\n  },\n});\n\ndeclare module 'wagmi' {\n  interface Register {\n    config: typeof config;\n  }\n}\n","const size = 256\nlet index = size\nlet buffer: string\n\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = ''\n    index = 0\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)\n    }\n  }\n  return buffer.substring(index, index++ + length)\n}\n","import type { ErrorType } from '../../errors/utils.js'\n\nexport type WithTimeoutErrorType = ErrorType\n\nexport function withTimeout<data>(\n  fn: ({\n    signal,\n  }: {\n    signal: AbortController['signal'] | null\n  }) => Promise<data>,\n  {\n    errorInstance = new Error('timed out'),\n    timeout,\n    signal,\n  }: {\n    // The error instance to throw when the timeout is reached.\n    errorInstance?: Error | undefined\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean | undefined\n  },\n): Promise<data> {\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId!: NodeJS.Timeout\n      try {\n        const controller = new AbortController()\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout) as NodeJS.Timeout // need to cast because bun globals.d.ts overrides @types/node\n        }\n        resolve(await fn({ signal: controller?.signal || null }))\n      } catch (err) {\n        if ((err as Error)?.name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n","import type {\n  AddEthereumChainParameter,\n  Address,\n  Chain,\n  Client,\n  ProviderConnectInfo,\n  ProviderMessage,\n} from 'viem'\n\nimport type { Transport } from '../createConfig.js'\nimport type { Emitter } from '../createEmitter.js'\nimport type { Storage } from '../createStorage.js'\nimport type { Compute, ExactPartial, StrictOmit } from '../types/utils.js'\n\nexport type ConnectorEventMap = {\n  change: {\n    accounts?: readonly Address[] | undefined\n    chainId?: number | undefined\n  }\n  connect: { accounts: readonly Address[]; chainId: number }\n  disconnect: never\n  error: { error: Error }\n  message: { type: string; data?: unknown | undefined }\n}\n\nexport type CreateConnectorFn<\n  provider = unknown,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n> = (config: {\n  chains: readonly [Chain, ...Chain[]]\n  emitter: Emitter<ConnectorEventMap>\n  storage?: Compute<Storage<storageItem>> | null | undefined\n  transports?: Record<number, Transport> | undefined\n}) => Compute<\n  {\n    readonly icon?: string | undefined\n    readonly id: string\n    readonly name: string\n    readonly rdns?: string | readonly string[] | undefined\n    readonly type: string\n\n    setup?(): Promise<void>\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(\n      parameters?:\n        | {\n            chainId?: number | undefined\n            isReconnecting?: boolean | undefined\n            withCapabilities?: withCapabilities | boolean | undefined\n          }\n        | undefined,\n    ): Promise<{\n      // TODO(v3): Add `capabilities` (e.g. `readonly { address: Address; capabilities: Record<string, unknown> | undefined }`)\n      accounts: withCapabilities extends true\n        ? readonly { address: Address; capabilities: Record<string, unknown> }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    disconnect(): Promise<void>\n    getAccounts(): Promise<readonly Address[]>\n    getChainId(): Promise<number>\n    getProvider(\n      parameters?: { chainId?: number | undefined } | undefined,\n    ): Promise<provider>\n    getClient?(\n      parameters?: { chainId?: number | undefined } | undefined,\n    ): Promise<Client>\n    isAuthorized(): Promise<boolean>\n    switchChain?(\n      parameters: Compute<{\n        addEthereumChainParameter?:\n          | ExactPartial<StrictOmit<AddEthereumChainParameter, 'chainId'>>\n          | undefined\n        chainId: number\n      }>,\n    ): Promise<Chain>\n\n    onAccountsChanged(accounts: string[]): void\n    onChainChanged(chainId: string): void\n    onConnect?(connectInfo: ProviderConnectInfo): void\n    onDisconnect(error?: Error | undefined): void\n    onMessage?(message: ProviderMessage): void\n  } & properties\n>\n\nexport function createConnector<\n  provider,\n  properties extends Record<string, unknown> = Record<string, unknown>,\n  storageItem extends Record<string, unknown> = Record<string, unknown>,\n  ///\n  createConnectorFn extends CreateConnectorFn<\n    provider,\n    properties,\n    storageItem\n  > = CreateConnectorFn<provider, properties, storageItem>,\n>(createConnectorFn: createConnectorFn) {\n  return createConnectorFn\n}\n","type Reviver = (key: string, value: any) => any\n\nexport function deserialize<type>(value: string, reviver?: Reviver): type {\n  return JSON.parse(value, (key, value_) => {\n    let value = value_\n    if (value?.__type === 'bigint') value = BigInt(value.value)\n    if (value?.__type === 'Map') value = new Map(value.value)\n    return reviver?.(key, value) ?? value\n  })\n}\n","import type { PartializedState } from './createConfig.js'\nimport type { Compute } from './types/utils.js'\nimport { deserialize as deserialize_ } from './utils/deserialize.js'\nimport { serialize as serialize_ } from './utils/serialize.js'\n\n// key-values for loose autocomplete and typing\nexport type StorageItemMap = {\n  recentConnectorId: string\n  state: PartializedState\n}\n\nexport type Storage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  ///\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n> = {\n  key: string\n  getItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key],\n    defaultValue extends value | null | undefined,\n  >(\n    key: key,\n    defaultValue?: defaultValue | undefined,\n  ):\n    | (defaultValue extends null ? value | null : value)\n    | Promise<defaultValue extends null ? value | null : value>\n  setItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key] | null,\n  >(key: key, value: value): void | Promise<void>\n  removeItem(key: keyof storageItemMap): void | Promise<void>\n}\n\nexport type BaseStorage = {\n  getItem(\n    key: string,\n  ): string | null | undefined | Promise<string | null | undefined>\n  setItem(key: string, value: string): void | Promise<void>\n  removeItem(key: string): void | Promise<void>\n}\n\nexport type CreateStorageParameters = {\n  deserialize?: (<type>(value: string) => type | unknown) | undefined\n  key?: string | undefined\n  serialize?: (<type>(value: type | any) => string) | undefined\n  storage?: Compute<BaseStorage> | undefined\n}\n\nexport function createStorage<\n  itemMap extends Record<string, unknown> = Record<string, unknown>,\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n>(parameters: CreateStorageParameters): Compute<Storage<storageItemMap>> {\n  const {\n    deserialize = deserialize_,\n    key: prefix = 'wagmi',\n    serialize = serialize_,\n    storage = noopStorage,\n  } = parameters\n\n  function unwrap<type>(value: type): type | Promise<type> {\n    if (value instanceof Promise) return value.then((x) => x).catch(() => null)\n    return value\n  }\n\n  return {\n    ...storage,\n    key: prefix,\n    async getItem(key, defaultValue) {\n      const value = storage.getItem(`${prefix}.${key as string}`)\n      const unwrapped = await unwrap(value)\n      if (unwrapped) return deserialize(unwrapped) ?? null\n      return (defaultValue ?? null) as any\n    },\n    async setItem(key, value) {\n      const storageKey = `${prefix}.${key as string}`\n      if (value === null) await unwrap(storage.removeItem(storageKey))\n      else await unwrap(storage.setItem(storageKey, serialize(value)))\n    },\n    async removeItem(key) {\n      await unwrap(storage.removeItem(`${prefix}.${key as string}`))\n    },\n  }\n}\n\nexport const noopStorage = {\n  getItem: () => null,\n  setItem: () => {},\n  removeItem: () => {},\n} satisfies BaseStorage\n\nexport function getDefaultStorage() {\n  const storage = (() => {\n    // biome-ignore lint/complexity/useOptionalChain: _\n    if (typeof window !== 'undefined' && window.localStorage)\n      return window.localStorage\n    return noopStorage\n  })()\n  return {\n    getItem(key) {\n      return storage.getItem(key)\n    },\n    removeItem(key) {\n      storage.removeItem(key)\n    },\n    setItem(key, value) {\n      try {\n        storage.setItem(key, value)\n        // silence errors by default (QuotaExceededError, SecurityError, etc.)\n      } catch {}\n    },\n  } satisfies BaseStorage\n}\n","import { BaseError } from './base.js'\n\nexport type UrlRequiredErrorType = UrlRequiredError & {\n  name: 'UrlRequiredError'\n}\nexport class UrlRequiredError extends BaseError {\n  constructor() {\n    super(\n      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',\n      {\n        docsPath: '/docs/clients/intro',\n        name: 'UrlRequiredError',\n      },\n    )\n  }\n}\n","import {\n  createStore as createMipd,\n  type EIP6963ProviderDetail,\n  type Store as MipdStore,\n} from 'mipd'\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  createClient,\n  type EIP1193RequestFn,\n  type ClientConfig as viem_ClientConfig,\n  type Transport as viem_Transport,\n} from 'viem'\nimport { persist, subscribeWithSelector } from 'zustand/middleware'\nimport { createStore, type Mutate, type StoreApi } from 'zustand/vanilla'\n\nimport type {\n  ConnectorEventMap,\n  CreateConnectorFn,\n} from './connectors/createConnector.js'\nimport { injected } from './connectors/injected.js'\nimport { createEmitter, type Emitter, type EventData } from './createEmitter.js'\nimport {\n  createStorage,\n  getDefaultStorage,\n  type Storage,\n} from './createStorage.js'\nimport { ChainNotConfiguredError } from './errors/config.js'\nimport type {\n  Compute,\n  ExactPartial,\n  LooseOmit,\n  OneOf,\n  RemoveUndefined,\n} from './types/utils.js'\nimport { uid } from './utils/uid.js'\nimport { version } from './version.js'\n\nexport function createConfig<\n  const chains extends readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport>,\n  const connectorFns extends readonly CreateConnectorFn[],\n>(\n  parameters: CreateConfigParameters<chains, transports, connectorFns>,\n): Config<chains, transports, connectorFns> {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: getDefaultStorage(),\n    }),\n    syncConnectedChain = true,\n    ssr = false,\n    ...rest\n  } = parameters\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  const mipd =\n    typeof window !== 'undefined' && multiInjectedProviderDiscovery\n      ? createMipd()\n      : undefined\n\n  const chains = createStore(() => rest.chains)\n  const connectors = createStore(() => {\n    const collection = []\n    const rdnsSet = new Set<string>()\n    for (const connectorFns of rest.connectors ?? []) {\n      const connector = setup(connectorFns)\n      collection.push(connector)\n      if (!ssr && connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          rdnsSet.add(rdns)\n        }\n      }\n    }\n    if (!ssr && mipd) {\n      const providers = mipd.getProviders()\n      for (const provider of providers) {\n        if (rdnsSet.has(provider.info.rdns)) continue\n        collection.push(setup(providerDetailToConnector(provider)))\n      }\n    }\n    return collection\n  })\n  function setup(connectorFn: CreateConnectorFn): Connector {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter<ConnectorEventMap>(uid())\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage,\n        transports: rest.transports,\n      }),\n      emitter,\n      uid: emitter.uid,\n    }\n\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect)\n    connector.setup?.()\n\n    return connector\n  }\n  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n    const { info } = providerDetail\n    const provider = providerDetail.provider as any\n    return injected({ target: { ...info, id: info.rdns, provider } })\n  }\n\n  const clients = new Map<number, Client<Transport, chains[number]>>()\n  function getClient<chainId extends chains[number]['id']>(\n    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},\n  ): Client<Transport, Extract<chains[number], { id: chainId }>> {\n    const chainId = config.chainId ?? store.getState().chainId\n    const chain = chains.getState().find((x) => x.id === chainId)\n\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError()\n\n    // If the target chain is not configured, use the client of the current chain.\n    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>\n    {\n      const client = clients.get(store.getState().chainId)\n      if (client && !chain) return client as Return\n      if (!chain) throw new ChainNotConfiguredError()\n    }\n\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId)\n      if (client) return client as Return\n    }\n\n    let client: Client<Transport, chains[number]>\n    if (rest.client) client = rest.client({ chain })\n    else {\n      const chainId = chain.id as chains[number]['id']\n      const chainIds = chains.getState().map((x) => x.id)\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties: Partial<viem_ClientConfig> = {}\n      const entries = Object.entries(rest) as [keyof typeof rest, any][]\n\n      for (const [key, value] of entries) {\n        if (\n          key === 'chains' ||\n          key === 'client' ||\n          key === 'connectors' ||\n          key === 'transports'\n        )\n          continue\n\n        if (typeof value === 'object') {\n          // check if value is chainId-specific since some values can be objects\n          // e.g. { batch: { multicall: { batchSize: 1024 } } }\n          if (chainId in value) properties[key] = value[chainId]\n          else {\n            // check if value is chainId-specific, but does not have value for current chainId\n            const hasChainSpecificValue = chainIds.some((x) => x in value)\n            if (hasChainSpecificValue) continue\n            properties[key] = value\n          }\n        } else properties[key] = value\n      }\n\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? { multicall: true },\n        transport: (parameters) =>\n          rest.transports[chainId]({ ...parameters, connectors }),\n      })\n    }\n\n    clients.set(chainId, client)\n    return client as Return\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function getInitialState(): State {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map<string, Connection>(),\n      current: null,\n      status: 'disconnected',\n    }\n  }\n\n  let currentVersion: number\n  const prefix = '0.0.0-canary-'\n  if (version.startsWith(prefix))\n    currentVersion = Number.parseInt(version.replace(prefix, ''), 10)\n  // use package major version to version store\n  else currentVersion = Number.parseInt(version.split('.')[0] ?? '0', 10)\n\n  const store = createStore(\n    subscribeWithSelector(\n      // only use persist middleware if storage exists\n      storage\n        ? persist(getInitialState, {\n            migrate(persistedState, version) {\n              if (version === currentVersion) return persistedState as State\n\n              const initialState = getInitialState()\n              const chainId = validatePersistedChainId(\n                persistedState,\n                initialState.chainId,\n              )\n              return { ...initialState, chainId }\n            },\n            name: 'store',\n            partialize(state) {\n              // Only persist \"critical\" store properties to preserve storage size.\n              return {\n                connections: {\n                  __type: 'Map',\n                  value: Array.from(state.connections.entries()).map(\n                    ([key, connection]) => {\n                      const { id, name, type, uid } = connection.connector\n                      const connector = { id, name, type, uid }\n                      return [key, { ...connection, connector }]\n                    },\n                  ),\n                } as unknown as PartializedState['connections'],\n                chainId: state.chainId,\n                current: state.current,\n              } satisfies PartializedState\n            },\n            merge(persistedState, currentState) {\n              // `status` should not be persisted as it messes with reconnection\n              if (\n                typeof persistedState === 'object' &&\n                persistedState &&\n                'status' in persistedState\n              )\n                delete persistedState.status\n              // Make sure persisted `chainId` is valid\n              const chainId = validatePersistedChainId(\n                persistedState,\n                currentState.chainId,\n              )\n              return {\n                ...currentState,\n                ...(persistedState as object),\n                chainId,\n              }\n            },\n            skipHydration: ssr,\n            storage: storage as Storage<Record<string, unknown>>,\n            version: currentVersion,\n          })\n        : getInitialState,\n    ),\n  )\n  store.setState(getInitialState())\n\n  function validatePersistedChainId(\n    persistedState: unknown,\n    defaultChainId: number,\n  ) {\n    return persistedState &&\n      typeof persistedState === 'object' &&\n      'chainId' in persistedState &&\n      typeof persistedState.chainId === 'number' &&\n      chains.getState().some((x) => x.id === persistedState.chainId)\n      ? persistedState.chainId\n      : defaultChainId\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Update default chain when connector chain changes\n  if (syncConnectedChain)\n    store.subscribe(\n      ({ connections, current }) =>\n        current ? connections.get(current)?.chainId : undefined,\n      (chainId) => {\n        // If chain is not configured, then don't switch over to it.\n        const isChainConfigured = chains\n          .getState()\n          .some((x) => x.id === chainId)\n        if (!isChainConfigured) return\n\n        return store.setState((x) => ({\n          ...x,\n          chainId: chainId ?? x.chainId,\n        }))\n      },\n    )\n\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe((providerDetails) => {\n    const connectorIdSet = new Set<string>()\n    const connectorRdnsSet = new Set<string>()\n    for (const connector of connectors.getState()) {\n      connectorIdSet.add(connector.id)\n      if (connector.rdns) {\n        const rdnsValues =\n          typeof connector.rdns === 'string' ? [connector.rdns] : connector.rdns\n        for (const rdns of rdnsValues) {\n          connectorRdnsSet.add(rdns)\n        }\n      }\n    }\n\n    const newConnectors: Connector[] = []\n    for (const providerDetail of providerDetails) {\n      if (connectorRdnsSet.has(providerDetail.info.rdns)) continue\n      const connector = setup(providerDetailToConnector(providerDetail))\n      if (connectorIdSet.has(connector.id)) continue\n      newConnectors.push(connector)\n    }\n\n    if (storage && !store.persist.hasHydrated()) return\n    connectors.setState((x) => [...x, ...newConnectors], true)\n  })\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function change(data: EventData<ConnectorEventMap, 'change'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (!connection) return x\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts:\n            (data.accounts as readonly [Address, ...Address[]]) ??\n            connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector,\n        }),\n      }\n    })\n  }\n  function connect(data: EventData<ConnectorEventMap, 'connect'>) {\n    // Disable handling if reconnecting/connecting\n    if (\n      store.getState().status === 'connecting' ||\n      store.getState().status === 'reconnecting'\n    )\n      return\n\n    store.setState((x) => {\n      const connector = connectors.getState().find((x) => x.uid === data.uid)\n      if (!connector) return x\n\n      if (connector.emitter.listenerCount('connect'))\n        connector.emitter.off('connect', change)\n      if (!connector.emitter.listenerCount('change'))\n        connector.emitter.on('change', change)\n      if (!connector.emitter.listenerCount('disconnect'))\n        connector.emitter.on('disconnect', disconnect)\n\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts as readonly [Address, ...Address[]],\n          chainId: data.chainId,\n          connector: connector,\n        }),\n        current: data.uid,\n        status: 'connected',\n      }\n    })\n  }\n  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (connection) {\n        const connector = connection.connector\n        if (connector.emitter.listenerCount('change'))\n          connection.connector.emitter.off('change', change)\n        if (connector.emitter.listenerCount('disconnect'))\n          connection.connector.emitter.off('disconnect', disconnect)\n        if (!connector.emitter.listenerCount('connect'))\n          connection.connector.emitter.on('connect', connect)\n      }\n\n      x.connections.delete(data.uid)\n\n      if (x.connections.size === 0)\n        return {\n          ...x,\n          connections: new Map(),\n          current: null,\n          status: 'disconnected',\n        }\n\n      const nextConnection = x.connections.values().next().value as Connection\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid,\n      }\n    })\n  }\n\n  return {\n    get chains() {\n      return chains.getState() as chains\n    },\n    get connectors() {\n      return connectors.getState() as Connector<connectorFns[number]>[]\n    },\n    storage,\n\n    getClient,\n    get state() {\n      return store.getState() as unknown as State<chains>\n    },\n    setState(value) {\n      let newState: State\n      if (typeof value === 'function') newState = value(store.getState() as any)\n      else newState = value\n\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState()\n      if (typeof newState !== 'object') newState = initialState\n      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))\n      if (isCorrupt) newState = initialState\n\n      store.setState(newState, true)\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(\n        selector as unknown as (state: State) => any,\n        listener,\n        options\n          ? ({\n              ...options,\n              fireImmediately: options.emitImmediately,\n              // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`\n            } as RemoveUndefined<typeof options>)\n          : undefined,\n      )\n    },\n\n    _internal: {\n      mipd,\n      async revalidate() {\n        // Check connections to see if they are still active\n        const state = store.getState()\n        const connections = state.connections\n        let current = state.current\n        for (const [, connection] of connections) {\n          const connector = connection.connector\n          // check if `connect.isAuthorized` exists\n          // partial connectors in storage do not have it\n          const isAuthorized = connector.isAuthorized\n            ? await connector.isAuthorized()\n            : false\n          if (isAuthorized) continue\n          // Remove stale connection\n          connections.delete(connector.uid)\n          if (current === connector.uid) current = null\n        }\n        // set connections\n        store.setState((x) => ({ ...x, connections, current }))\n      },\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports as transports,\n      chains: {\n        setState(value) {\n          const nextChains = (\n            typeof value === 'function' ? value(chains.getState()) : value\n          ) as chains\n          if (nextChains.length === 0) return\n          return chains.setState(nextChains, true)\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener)\n        },\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup: setup as <connectorFn extends CreateConnectorFn>(\n          connectorFn: connectorFn,\n        ) => Connector<connectorFn>,\n        setState(value) {\n          return connectors.setState(\n            typeof value === 'function' ? value(connectors.getState()) : value,\n            true,\n          )\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener)\n        },\n      },\n      events: { change, connect, disconnect },\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type CreateConfigParameters<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = Compute<\n  {\n    chains: chains\n    connectors?: connectorFns | undefined\n    multiInjectedProviderDiscovery?: boolean | undefined\n    storage?: Storage | null | undefined\n    ssr?: boolean | undefined\n    syncConnectedChain?: boolean | undefined\n  } & OneOf<\n    | ({ transports: transports } & {\n        [key in keyof ClientConfig]?:\n          | ClientConfig[key]\n          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }\n          | undefined\n      })\n    | {\n        client(parameters: {\n          chain: chains[number]\n        }): Client<transports[chains[number]['id']], chains[number]>\n      }\n  >\n>\n\nexport type Config<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n  connectorFns extends\n    readonly CreateConnectorFn[] = readonly CreateConnectorFn[],\n> = {\n  readonly chains: chains\n  readonly connectors: readonly Connector<connectorFns[number]>[]\n  readonly storage: Storage | null\n\n  readonly state: State<chains>\n  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(\n    value: State<tchains> | ((state: State<tchains>) => State<tchains>),\n  ): void\n  subscribe<state>(\n    selector: (state: State<chains>) => state,\n    listener: (state: state, previousState: state) => void,\n    options?:\n      | {\n          emitImmediately?: boolean | undefined\n          equalityFn?: ((a: state, b: state) => boolean) | undefined\n        }\n      | undefined,\n  ): () => void\n\n  getClient<chainId extends chains[number]['id']>(parameters?: {\n    chainId?: chainId | chains[number]['id'] | undefined\n  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>\n\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @internal\n   */\n  _internal: Internal<chains, transports>\n}\n\ntype Internal<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly mipd: MipdStore | undefined\n  revalidate: () => Promise<void>\n  readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>\n  readonly ssr: boolean\n  readonly syncConnectedChain: boolean\n  readonly transports: transports\n\n  chains: {\n    setState(\n      value:\n        | readonly [Chain, ...Chain[]]\n        | ((\n            state: readonly [Chain, ...Chain[]],\n          ) => readonly [Chain, ...Chain[]]),\n    ): void\n    subscribe(\n      listener: (\n        state: readonly [Chain, ...Chain[]],\n        prevState: readonly [Chain, ...Chain[]],\n      ) => void,\n    ): () => void\n  }\n  connectors: {\n    providerDetailToConnector(\n      providerDetail: EIP6963ProviderDetail,\n    ): CreateConnectorFn\n    setup<connectorFn extends CreateConnectorFn>(\n      connectorFn: connectorFn,\n    ): Connector<connectorFn>\n    setState(value: Connector[] | ((state: Connector[]) => Connector[])): void\n    subscribe(\n      listener: (state: Connector[], prevState: Connector[]) => void,\n    ): () => void\n  }\n  events: {\n    change(data: EventData<ConnectorEventMap, 'change'>): void\n    connect(data: EventData<ConnectorEventMap, 'connect'>): void\n    disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void\n  }\n}\n\nexport type State<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n> = {\n  chainId: chains[number]['id']\n  connections: Map<string, Connection>\n  current: string | null\n  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'\n}\n\nexport type PartializedState = Compute<\n  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>\n>\n\nexport type Connection = {\n  accounts: readonly [Address, ...Address[]]\n  chainId: number\n  connector: Connector\n}\n\nexport type Connector<\n  createConnectorFn extends CreateConnectorFn = CreateConnectorFn,\n> = ReturnType<createConnectorFn> & {\n  emitter: Emitter<ConnectorEventMap>\n  uid: string\n}\n\nexport type Transport<\n  type extends string = string,\n  rpcAttributes = Record<string, any>,\n  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = (\n  params: Parameters<\n    viem_Transport<type, rpcAttributes, eip1193RequestFn>\n  >[0] & {\n    connectors?: StoreApi<Connector[]> | undefined\n  },\n) => ReturnType<viem_Transport<type, rpcAttributes, eip1193RequestFn>>\n\ntype ClientConfig = LooseOmit<\n  viem_ClientConfig,\n  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'\n>\n","import {\n  HttpRequestError,\n  type HttpRequestErrorType as HttpRequestErrorType_,\n  TimeoutError,\n  type TimeoutErrorType,\n} from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport type { MaybePromise } from '../../types/utils.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from '../promise/withTimeout.js'\nimport { stringify } from '../stringify.js'\nimport { idCache } from './id.js'\n\nexport type HttpRpcClientOptions = {\n  /** Override for the fetch function used to make requests. */\n  fetchFn?:\n    | ((input: string | URL | Request, init?: RequestInit) => Promise<Response>)\n    | undefined\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: Omit<RequestInit, 'body'> | undefined\n  /** A callback to handle the request. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: number | undefined\n}\n\nexport type HttpRequestParameters<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = {\n  /** The RPC request body. */\n  body: body\n  /** Override for the fetch function used to make requests. */\n  fetchFn?: HttpRpcClientOptions['fetchFn'] | undefined\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined\n  /** A callback to handle the response. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: HttpRpcClientOptions['timeout'] | undefined\n}\n\nexport type HttpRequestReturnType<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = body extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpRequestErrorType =\n  | HttpRequestErrorType_\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nexport type HttpRpcClient = {\n  request<body extends RpcRequest | RpcRequest[]>(\n    params: HttpRequestParameters<body>,\n  ): Promise<HttpRequestReturnType<body>>\n}\n\nexport function getHttpRpcClient(\n  url: string,\n  options: HttpRpcClientOptions = {},\n): HttpRpcClient {\n  return {\n    async request(params) {\n      const {\n        body,\n        fetchFn = options.fetchFn ?? fetch,\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000,\n      } = params\n\n      const fetchOptions = {\n        ...(options.fetchOptions ?? {}),\n        ...(params.fetchOptions ?? {}),\n      }\n\n      const { headers, method, signal: signal_ } = fetchOptions\n\n      try {\n        const response = await withTimeout(\n          async ({ signal }) => {\n            const init: RequestInit = {\n              ...fetchOptions,\n              body: Array.isArray(body)\n                ? stringify(\n                    body.map((body) => ({\n                      jsonrpc: '2.0',\n                      id: body.id ?? idCache.take(),\n                      ...body,\n                    })),\n                  )\n                : stringify({\n                    jsonrpc: '2.0',\n                    id: body.id ?? idCache.take(),\n                    ...body,\n                  }),\n              headers: {\n                'Content-Type': 'application/json',\n                ...headers,\n              },\n              method: method || 'POST',\n              signal: signal_ || (timeout > 0 ? signal : null),\n            }\n            const request = new Request(url, init)\n            const args = (await onRequest?.(request, init)) ?? { ...init, url }\n            const response = await fetchFn(args.url ?? url, args)\n            return response\n          },\n          {\n            errorInstance: new TimeoutError({ body, url }),\n            timeout,\n            signal: true,\n          },\n        )\n\n        if (onResponse) await onResponse(response)\n\n        let data: any\n        if (\n          response.headers.get('Content-Type')?.startsWith('application/json')\n        )\n          data = await response.json()\n        else {\n          data = await response.text()\n          try {\n            data = JSON.parse(data || '{}')\n          } catch (err) {\n            if (response.ok) throw err\n            data = { error: data }\n          }\n        }\n\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url,\n          })\n        }\n\n        return data\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err\n        if (err instanceof TimeoutError) throw err\n        throw new HttpRequestError({\n          body,\n          cause: err as Error,\n          url,\n        })\n      }\n    },\n  }\n}\n","import { RpcRequestError } from '../../errors/request.js'\nimport {\n  UrlRequiredError,\n  type UrlRequiredErrorType,\n} from '../../errors/transport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { EIP1193RequestFn, RpcSchema } from '../../types/eip1193.js'\nimport type { RpcRequest } from '../../types/rpc.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport {\n  getHttpRpcClient,\n  type HttpRpcClientOptions,\n} from '../../utils/rpc/http.js'\n\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n\nexport type HttpTransportConfig<\n  rpcSchema extends RpcSchema | undefined = undefined,\n  raw extends boolean = false,\n> = {\n  /**\n   * Whether to enable Batch JSON-RPC.\n   * @link https://www.jsonrpc.org/specification#batch\n   */\n  batch?:\n    | boolean\n    | {\n        /** The maximum number of JSON-RPC requests to send in a batch. @default 1_000 */\n        batchSize?: number | undefined\n        /** The maximum number of milliseconds to wait before sending a batch. @default 0 */\n        wait?: number | undefined\n      }\n    | undefined\n  fetchFn?: HttpRpcClientOptions['fetchFn'] | undefined\n  /**\n   * Request configuration to pass to `fetch`.\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/fetch\n   */\n  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined\n  /** A callback to handle the response from `fetch`. */\n  onFetchRequest?: HttpRpcClientOptions['onRequest'] | undefined\n  /** A callback to handle the response from `fetch`. */\n  onFetchResponse?: HttpRpcClientOptions['onResponse'] | undefined\n  /** The key of the HTTP transport. */\n  key?: TransportConfig['key'] | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?: TransportConfig['methods'] | undefined\n  /** The name of the HTTP transport. */\n  name?: TransportConfig['name'] | undefined\n  /** Whether to return JSON RPC errors as responses instead of throwing. */\n  raw?: raw | boolean | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n  /** Typed JSON-RPC schema for the transport. */\n  rpcSchema?: rpcSchema | RpcSchema | undefined\n  /** The timeout (in ms) for the HTTP request. Default: 10_000 */\n  timeout?: TransportConfig['timeout'] | undefined\n}\n\nexport type HttpTransport<\n  rpcSchema extends RpcSchema | undefined = undefined,\n  raw extends boolean = false,\n> = Transport<\n  'http',\n  {\n    fetchOptions?: HttpTransportConfig['fetchOptions'] | undefined\n    url?: string | undefined\n  },\n  EIP1193RequestFn<rpcSchema, raw>\n>\n\nexport type HttpTransportErrorType =\n  | CreateTransportErrorType\n  | UrlRequiredErrorType\n  | ErrorType\n\n/**\n * @description Creates a HTTP transport that connects to a JSON-RPC API.\n */\nexport function http<\n  rpcSchema extends RpcSchema | undefined = undefined,\n  raw extends boolean = false,\n>(\n  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\n  url?: string | undefined,\n  config: HttpTransportConfig<rpcSchema, raw> = {},\n): HttpTransport<rpcSchema, raw> {\n  const {\n    batch,\n    fetchFn,\n    fetchOptions,\n    key = 'http',\n    methods,\n    name = 'HTTP JSON-RPC',\n    onFetchRequest,\n    onFetchResponse,\n    retryDelay,\n    raw,\n  } = config\n  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\n    const { batchSize = 1000, wait = 0 } =\n      typeof batch === 'object' ? batch : {}\n    const retryCount = config.retryCount ?? retryCount_\n    const timeout = timeout_ ?? config.timeout ?? 10_000\n    const url_ = url || chain?.rpcUrls.default.http[0]\n    if (!url_) throw new UrlRequiredError()\n\n    const rpcClient = getHttpRpcClient(url_, {\n      fetchFn,\n      fetchOptions,\n      onRequest: onFetchRequest,\n      onResponse: onFetchResponse,\n      timeout,\n    })\n\n    return createTransport(\n      {\n        key,\n        methods,\n        name,\n        async request({ method, params }) {\n          const body = { method, params }\n\n          const { schedule } = createBatchScheduler({\n            id: url_,\n            wait,\n            shouldSplitBatch(requests) {\n              return requests.length > batchSize\n            },\n            fn: (body: RpcRequest[]) =>\n              rpcClient.request({\n                body,\n              }),\n            sort: (a, b) => a.id - b.id,\n          })\n\n          const fn = async (body: RpcRequest) =>\n            batch\n              ? schedule(body)\n              : [\n                  await rpcClient.request({\n                    body,\n                  }),\n                ]\n\n          const [{ error, result }] = await fn(body)\n\n          if (raw) return { error, result }\n          if (error)\n            throw new RpcRequestError({\n              body,\n              error,\n              url: url_,\n            })\n          return result\n        },\n        retryCount,\n        retryDelay,\n        timeout,\n        type: 'http',\n      },\n      {\n        fetchOptions,\n        url: url_,\n      },\n    )\n  }\n}\n","import {\n  type AddEthereumChainParameter,\n  type Address,\n  type EIP1193Provider,\n  getAddress,\n  numberToHex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nimport type { Connector } from '../createConfig.js'\nimport { ChainNotConfiguredError } from '../errors/config.js'\nimport { ProviderNotFoundError } from '../errors/connector.js'\nimport type { Compute } from '../types/utils.js'\nimport { createConnector } from './createConnector.js'\n\nexport type InjectedParameters = {\n  /**\n   * Some injected providers do not support programmatic disconnect.\n   * This flag simulates the disconnect behavior by keeping track of connection status in storage.\n   * @default true\n   */\n  shimDisconnect?: boolean | undefined\n  /**\n   * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) Ethereum Provider to target\n   */\n  target?: TargetId | Target | (() => Target | undefined) | undefined\n  unstable_shimAsyncInject?: boolean | number | undefined\n}\n\ninjected.type = 'injected' as const\nexport function injected(parameters: InjectedParameters = {}) {\n  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters\n\n  function getTarget(): Compute<Target & { id: string }> {\n    const target = parameters.target\n    if (typeof target === 'function') {\n      const result = target()\n      if (result) return result\n    }\n\n    if (typeof target === 'object') return target\n\n    if (typeof target === 'string')\n      return {\n        ...(targetMap[target as keyof typeof targetMap] ?? {\n          id: target,\n          name: `${target[0]!.toUpperCase()}${target.slice(1)}`,\n          provider: `is${target[0]!.toUpperCase()}${target.slice(1)}`,\n        }),\n      }\n\n    return {\n      id: 'injected',\n      name: 'Injected',\n      provider(window) {\n        return window?.ethereum\n      },\n    }\n  }\n\n  type Provider = WalletProvider | undefined\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n  type StorageItem = {\n    [_ in 'injected.connected' | `${string}.disconnected`]: true\n  }\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let connect: Connector['onConnect'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    get icon() {\n      return getTarget().icon\n    },\n    get id() {\n      return getTarget().id\n    },\n    get name() {\n      return getTarget().name\n    },\n    type: injected.type,\n    async setup() {\n      const provider = await this.getProvider()\n      // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n      if (provider?.on && parameters.target) {\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting, withCapabilities } = {}) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      let accounts: readonly Address[] = []\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])\n      else if (shimDisconnect) {\n        // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n        try {\n          const permissions = await provider.request({\n            method: 'wallet_requestPermissions',\n            params: [{ eth_accounts: {} }],\n          })\n          accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(\n            (x) => getAddress(x),\n          )\n          // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n          // switch to `'eth_accounts'` ordering if more than one account is connected\n          // https://github.com/wevm/wagmi/issues/4140\n          if (accounts.length > 0) {\n            const sortedAccounts = await this.getAccounts()\n            accounts = sortedAccounts\n          }\n        } catch (err) {\n          const error = err as RpcError\n          // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n          // Only bubble up error if user rejects request\n          if (error.code === UserRejectedRequestError.code)\n            throw new UserRejectedRequestError(error)\n          // Or prompt is already open\n          if (error.code === ResourceUnavailableRpcError.code) throw error\n        }\n      }\n\n      try {\n        if (!accounts?.length && !isReconnecting) {\n          const requestedAccounts = await provider.request({\n            method: 'eth_requestAccounts',\n          })\n          accounts = requestedAccounts.map((x) => getAddress(x))\n        }\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n\n        // Add connected shim if no target exists\n        if (!parameters.target)\n          await config.storage?.setItem('injected.connected', true)\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n\n      // Experimental support for MetaMask disconnect\n      // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n      try {\n        // Adding timeout as not all wallets support this method and can hang\n        // https://github.com/wevm/wagmi/issues/4064\n        await withTimeout(\n          () =>\n            // TODO: Remove explicit type for viem@3\n            provider.request<{\n              Method: 'wallet_revokePermissions'\n              Parameters: [permissions: { eth_accounts: Record<string, any> }]\n              ReturnType: null\n            }>({\n              // `'wallet_revokePermissions'` added in `viem@2.10.3`\n              method: 'wallet_revokePermissions',\n              params: [{ eth_accounts: {} }],\n            }),\n          { timeout: 100 },\n        )\n      } catch {}\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) {\n        await config.storage?.setItem(`${this.id}.disconnected`, true)\n      }\n\n      if (!parameters.target)\n        await config.storage?.removeItem('injected.connected')\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return Number(hexChainId)\n    },\n    async getProvider() {\n      if (typeof window === 'undefined') return undefined\n\n      let provider: Provider\n      const target = getTarget()\n      if (typeof target.provider === 'function')\n        provider = target.provider(window as Window | undefined)\n      else if (typeof target.provider === 'string')\n        provider = findProvider(window, target.provider)\n      else provider = target.provider\n\n      // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n      // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n      if (provider && !provider.removeListener) {\n        // Try using `off` handler if it exists, otherwise noop\n        if ('off' in provider && typeof provider.off === 'function')\n          provider.removeListener =\n            provider.off as typeof provider.removeListener\n        else provider.removeListener = () => {}\n      }\n\n      return provider\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem(`${this.id}.disconnected`))\n        if (isDisconnected) return false\n\n        // Don't allow injected connector to connect if no target is set and it hasn't already connected\n        // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n        // automatically whenever there is a targeted connector configured.\n        if (!parameters.target) {\n          const connected = await config.storage?.getItem('injected.connected')\n          if (!connected) return false\n        }\n\n        const provider = await this.getProvider()\n        if (!provider) {\n          if (\n            unstable_shimAsyncInject !== undefined &&\n            unstable_shimAsyncInject !== false\n          ) {\n            // If no provider is found, check for async injection\n            // https://github.com/wevm/references/issues/167\n            // https://github.com/MetaMask/detect-provider\n            const handleEthereum = async () => {\n              if (typeof window !== 'undefined')\n                window.removeEventListener(\n                  'ethereum#initialized',\n                  handleEthereum,\n                )\n              const provider = await this.getProvider()\n              return !!provider\n            }\n            const timeout =\n              typeof unstable_shimAsyncInject === 'number'\n                ? unstable_shimAsyncInject\n                : 1_000\n            const res = await Promise.race([\n              ...(typeof window !== 'undefined'\n                ? [\n                    new Promise<boolean>((resolve) =>\n                      window.addEventListener(\n                        'ethereum#initialized',\n                        () => resolve(handleEthereum()),\n                        { once: true },\n                      ),\n                    ),\n                  ]\n                : []),\n              new Promise<boolean>((resolve) =>\n                setTimeout(() => resolve(handleEthereum()), timeout),\n              ),\n            ])\n            if (res) return true\n          }\n\n          throw new ProviderNotFoundError()\n        }\n\n        // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n        // immediately resolve JSON-RPC requests on page load.\n        const accounts = await withRetry(() => this.getAccounts())\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const promise = new Promise<void>((resolve) => {\n        const listener = ((data) => {\n          if ('chainId' in data && data.chainId === chainId) {\n            config.emitter.off('change', listener)\n            resolve()\n          }\n        }) satisfies Parameters<typeof config.emitter.on>[1]\n        config.emitter.on('change', listener)\n      })\n\n      try {\n        await Promise.all([\n          provider\n            .request({\n              method: 'wallet_switchEthereumChain',\n              params: [{ chainId: numberToHex(chainId) }],\n            })\n            // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n            // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n            // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n            // this callback or an externally emitted `'chainChanged'` event.\n            // https://github.com/MetaMask/metamask-extension/issues/24247\n            .then(async () => {\n              const currentChainId = await this.getChainId()\n              if (currentChainId === chainId)\n                config.emitter.emit('change', { chainId })\n            }),\n          promise,\n        ])\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            const { default: blockExplorer, ...blockExplorers } =\n              chain.blockExplorers ?? {}\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else if (blockExplorer)\n              blockExplorerUrls = [\n                blockExplorer.url,\n                ...Object.values(blockExplorers).map((x) => x.url),\n              ]\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await Promise.all([\n              provider\n                .request({\n                  method: 'wallet_addEthereumChain',\n                  params: [addEthereumChain],\n                })\n                .then(async () => {\n                  const currentChainId = await this.getChainId()\n                  if (currentChainId === chainId)\n                    config.emitter.emit('change', { chainId })\n                  else\n                    throw new UserRejectedRequestError(\n                      new Error('User rejected switch after adding network.'),\n                    )\n                }),\n              promise,\n            ])\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        throw new SwitchChainError(error)\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect()\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n        // Remove disconnected shim if it exists\n        if (shimDisconnect)\n          await config.storage?.removeItem(`${this.id}.disconnected`)\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      // Manage EIP-1193 event listeners\n      const provider = await this.getProvider()\n      if (provider) {\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect')\n\n      // Manage EIP-1193 event listeners\n      if (provider) {\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n      }\n    },\n  }))\n}\n\nconst targetMap = {\n  coinbaseWallet: {\n    id: 'coinbaseWallet',\n    name: 'Coinbase Wallet',\n    provider(window) {\n      if (window?.coinbaseWalletExtension) return window.coinbaseWalletExtension\n      return findProvider(window, 'isCoinbaseWallet')\n    },\n  },\n  metaMask: {\n    id: 'metaMask',\n    name: 'MetaMask',\n    provider(window) {\n      return findProvider(window, (provider) => {\n        if (!provider.isMetaMask) return false\n        // Brave tries to make itself look like MetaMask\n        // Could also try RPC `web3_clientVersion` if following is unreliable\n        if (provider.isBraveWallet && !provider._events && !provider._state)\n          return false\n        // Other wallets that try to look like MetaMask\n        const flags = [\n          'isApexWallet',\n          'isAvalanche',\n          'isBitKeep',\n          'isBlockWallet',\n          'isKuCoinWallet',\n          'isMathWallet',\n          'isOkxWallet',\n          'isOKExWallet',\n          'isOneInchIOSWallet',\n          'isOneInchAndroidWallet',\n          'isOpera',\n          'isPhantom',\n          'isPortal',\n          'isRabby',\n          'isTokenPocket',\n          'isTokenary',\n          'isUniswapWallet',\n          'isZerion',\n        ] satisfies WalletProviderFlags[]\n        for (const flag of flags) if (provider[flag]) return false\n        return true\n      })\n    },\n  },\n  phantom: {\n    id: 'phantom',\n    name: 'Phantom',\n    provider(window) {\n      if (window?.phantom?.ethereum) return window.phantom?.ethereum\n      return findProvider(window, 'isPhantom')\n    },\n  },\n} as const satisfies TargetMap\n\ntype TargetMap = { [_ in TargetId]?: Target | undefined }\n\ntype Target = {\n  icon?: string | undefined\n  id: string\n  name: string\n  provider:\n    | WalletProviderFlags\n    | WalletProvider\n    | ((window?: Window | undefined) => WalletProvider | undefined)\n}\n\n/** @deprecated */\ntype TargetId = Compute<WalletProviderFlags> extends `is${infer name}`\n  ? name extends `${infer char}${infer rest}`\n    ? `${Lowercase<char>}${rest}`\n    : never\n  : never\n\n/**\n * @deprecated As of 2024/10/16, we are no longer accepting new provider flags as EIP-6963 should be used instead.\n */\ntype WalletProviderFlags =\n  | 'isApexWallet'\n  | 'isAvalanche'\n  | 'isBackpack'\n  | 'isBifrost'\n  | 'isBitKeep'\n  | 'isBitski'\n  | 'isBlockWallet'\n  | 'isBraveWallet'\n  | 'isCoinbaseWallet'\n  | 'isDawn'\n  | 'isEnkrypt'\n  | 'isExodus'\n  | 'isFrame'\n  | 'isFrontier'\n  | 'isGamestop'\n  | 'isHyperPay'\n  | 'isImToken'\n  | 'isKuCoinWallet'\n  | 'isMathWallet'\n  | 'isMetaMask'\n  | 'isOkxWallet'\n  | 'isOKExWallet'\n  | 'isOneInchAndroidWallet'\n  | 'isOneInchIOSWallet'\n  | 'isOpera'\n  | 'isPhantom'\n  | 'isPortal'\n  | 'isRabby'\n  | 'isRainbow'\n  | 'isStatus'\n  | 'isTally'\n  | 'isTokenPocket'\n  | 'isTokenary'\n  | 'isTrust'\n  | 'isTrustWallet'\n  | 'isUniswapWallet'\n  | 'isXDEFI'\n  | 'isZerion'\n\ntype WalletProvider = Compute<\n  EIP1193Provider & {\n    [key in WalletProviderFlags]?: true | undefined\n  } & {\n    providers?: WalletProvider[] | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _events?: { connect?: (() => void) | undefined } | undefined\n    /** Only exists in MetaMask as of 2022/04/03 */\n    _state?:\n      | {\n          accounts?: string[]\n          initialized?: boolean\n          isConnected?: boolean\n          isPermanentlyDisconnected?: boolean\n          isUnlocked?: boolean\n        }\n      | undefined\n  }\n>\n\ntype Window = {\n  coinbaseWalletExtension?: WalletProvider | undefined\n  ethereum?: WalletProvider | undefined\n  phantom?: { ethereum: WalletProvider } | undefined\n}\n\nfunction findProvider(\n  window: globalThis.Window | Window | undefined,\n  select?: WalletProviderFlags | ((provider: WalletProvider) => boolean),\n) {\n  function isProvider(provider: WalletProvider) {\n    if (typeof select === 'function') return select(provider)\n    if (typeof select === 'string') return provider[select]\n    return true\n  }\n\n  const ethereum = (window as Window).ethereum\n  if (ethereum?.providers)\n    return ethereum.providers.find((provider) => isProvider(provider))\n  if (ethereum && isProvider(ethereum)) return ethereum\n  return undefined\n}\n","import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","function createIdStore() {\n  return {\n    current: 0,\n    take() {\n      return this.current++\n    },\n    reset() {\n      this.current = 0\n    },\n  }\n}\n\nexport const idCache = /*#__PURE__*/ createIdStore()\n","import { EventEmitter } from 'eventemitter3'\n\ntype EventMap = Record<string, object | never>\ntype EventKey<eventMap extends EventMap> = string & keyof eventMap\ntype EventFn<parameters extends unknown[] = any[]> = (\n  ...parameters: parameters\n) => void\nexport type EventData<\n  eventMap extends EventMap,\n  eventName extends keyof eventMap,\n> = (eventMap[eventName] extends [never] ? unknown : eventMap[eventName]) & {\n  uid: string\n}\n\nexport class Emitter<eventMap extends EventMap> {\n  _emitter = new EventEmitter()\n\n  constructor(public uid: string) {}\n\n  on<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.on(eventName, fn as EventFn)\n  }\n\n  once<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.once(eventName, fn as EventFn)\n  }\n\n  off<key extends EventKey<eventMap>>(\n    eventName: key,\n    fn: EventFn<\n      eventMap[key] extends [never]\n        ? [{ uid: string }]\n        : [data: eventMap[key] & { uid: string }]\n    >,\n  ) {\n    this._emitter.off(eventName, fn as EventFn)\n  }\n\n  emit<key extends EventKey<eventMap>>(\n    eventName: key,\n    ...params: eventMap[key] extends [never] ? [] : [data: eventMap[key]]\n  ) {\n    const data = params[0]\n    this._emitter.emit(eventName, { uid: this.uid, ...data })\n  }\n\n  listenerCount<key extends EventKey<eventMap>>(eventName: key) {\n    return this._emitter.listenerCount(eventName)\n  }\n}\n\nexport function createEmitter<eventMap extends EventMap>(uid: string) {\n  return new Emitter<eventMap>(uid)\n}\n","/**\n * Get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys: string[], cutoff: number) {\n  return keys.slice(0, cutoff).join('.') || '.'\n}\n\n/**\n * Faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\nfunction getCutoff(array: any[], value: any) {\n  const { length } = array\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1\n    }\n  }\n\n  return 0\n}\n\ntype StandardReplacer = (key: string, value: any) => any\ntype CircularReplacer = (key: string, value: any, referenceKey: string) => any\n\n/**\n * Create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(\n  replacer?: StandardReplacer | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n): StandardReplacer {\n  const hasReplacer = typeof replacer === 'function'\n  const hasCircularReplacer = typeof circularReplacer === 'function'\n\n  const cache: any[] = []\n  const keys: string[] = []\n\n  return function replace(this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this)\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this\n        } else {\n          cache.splice(thisCutoff)\n          keys.splice(thisCutoff)\n        }\n\n        keys[keys.length] = key\n\n        const valueCutoff = getCutoff(cache, value)\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer\n            ? circularReplacer.call(\n                this,\n                key,\n                value,\n                getReferenceKey(keys, valueCutoff),\n              )\n            : `[ref=${getReferenceKey(keys, valueCutoff)}]`\n        }\n      } else {\n        cache[0] = value\n        keys[0] = key\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value\n  }\n}\n\n/**\n * Stringifier that handles circular values\n *\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\nexport function serialize(\n  value: any,\n  replacer?: StandardReplacer | null | undefined,\n  indent?: number | null | undefined,\n  circularReplacer?: CircularReplacer | null | undefined,\n) {\n  return JSON.stringify(\n    value,\n    createReplacer((key, value_) => {\n      let value = value_\n      if (typeof value === 'bigint')\n        value = { __type: 'bigint', value: value_.toString() }\n      if (value instanceof Map)\n        value = { __type: 'Map', value: Array.from(value_.entries()) }\n      return replacer?.(key, value) ?? value\n    }, circularReplacer),\n    indent ?? undefined,\n  )\n}\n","import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type {\n  DefaultError,\n  MutationFunctionContext,\n  MutationOptions,\n  NotifyEvent,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TOnMutateResult>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TOnMutateResult>,\n    state?: MutationState<TData, TError, TVariables, TOnMutateResult>,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TOnMutateResult = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TOnMutateResult> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n","import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TOnMutateResult = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"],"names":["ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort","UnrecognizedActionError","unstable_isUnrecognizedActionError","args","name","error","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","TemporaryRedirect","getStore","isAction","push","replace","PermanentRedirect","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","prefix","httpStatus","has","notFound","DIGEST","forbidden","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","unauthorized","isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","err","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","route","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","listeners","addEventListener","i","length","once","catch","ignoreReject","underlying","requestStore","stage","stagedRendering","delayUntilStage","resolve","setTimeout","isPostpone","REACT_POSTPONE_TYPE","Symbol","for","$$typeof","BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","reason","isNextRouterError","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","description","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","code","METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","then","NEXT_RUNTIME","nextTick","setImmediate","r","InvariantError","message","options","endsWith","RenderStage","StagedRenderingController","abortSignal","currentStage","runtimeStagePromise","createPromiseWithResolvers","dynamicStagePromise","promise","advanceStage","getStagePromise","waitForStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","useDynamicRouteParams","useDynamicSearchParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","store","workUnitStore","forceDynamic","forceStatic","dynamicShouldError","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","controller","abort","errorWithStack","Dynamic","prerenderSignal","workUnitAsyncStorage","assertPostpone","createPostponeReason","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","serverDynamic","clientDynamic","filter","access","map","line","AbortController","cacheSignal","inputReady","getRuntimeStagePromise","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","use","renderSignal","throwForMissingRequestStore","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","console","dev","hasReadableErrorStacks","prelude","result","unstable_rethrow","cause","ServerInsertedHTMLContext","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","navigationPromises","NavigationPromisesContext","pathname","PathnameContext","router","AppRouterContext","params","PathParamsContext","parallelRouteKey","context","LayoutRouterContext","selectedLayoutSegmentsPromises","getSelectedLayoutSegmentPath","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","computeSelectedLayoutSegment","Analytics"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,32,33,34,35,37,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}